---
title: 'Addendum: Using Quantum Hardware'
publishedAt: '2025-09-10'
week: 2
summary: 'This page contains the addendum for week 2 of BU Quantum.'
---
<KatexSpan>
This addendum gives a quick introduction to running your code on IBM quantum hardware through Qiskit. You will need to enter a credit card to do this, but you are allocated 10 free minutes of execution per month. The code in this addendum works as of the time of writing, but Qiskit is always being updated, so new versions may break this.

First, make an account on [IBM Quantum Platform](https://quantum.cloud.ibm.com/) and verify your account with your card. Then, create and save your [API key](https://cloud.ibm.com/iam/apikeys) and [CRN](https://quantum.cloud.ibm.com/instances).

You can then run the following block of code:
```py
from qiskit_ibm_runtime import QiskitRuntimeService

QiskitRuntimeService.save_account(
    channel="ibm_cloud",
    token="[API key]",
    instance="[IBM Cloud CRN]",
    name="[Account name]",
)
```
Make sure not to include the brackets in each string parameter. The account name can be whatever you'd like. Once you successfully run this code with your information, you should be able to send jobs to quantum hardware locally without ever needing to login again.

Suppose you have some quantum circuit `qc`; for the purposes of this example, I will prepare the $|\Phi^\{+\}\rangle$ state in `qc`, which we will be discussing in the next lesson.
```py
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()
qc.draw()
```
This will output the following circuit:
```
        ┌───┐      ░ ┌─┐   
   q_0: ┤ H ├──■───░─┤M├───
        └───┘┌─┴─┐ ░ └╥┘┌─┐
   q_1: ─────┤ X ├─░──╫─┤M├
             └───┘ ░  ║ └╥┘
meas: 2/══════════════╩══╩═
                      0  1 
```
We can send the job to execute `qc` to a real quantum computer using the following code.
```py
from qiskit_ibm_runtime import SamplerV2, QiskitRuntimeService
from qiskit.transpiler import generate_preset_pass_manager

service = QiskitRuntimeService()
backend = service.least_busy(
    operational=True, simulator=False
)
 
pm = generate_preset_pass_manager(
    optimization_level=1, 
    backend=backend,
)
isa_circuit = pm.run(qc)

sampler = SamplerV2(mode=backend)
sampler.run([isa_circuit], shots=2048)
```
Let's go over this code line by line. We first get `backend`, which is the current least busy quantum computer that is operational and not a simulator. We then need to transpile this code; we do so using the `generate_preset_pass_manager` function. Setting the `optimization_level` to 1 just means that there will be light optimization applied, and we will transpile it for our specific quantum backend. We then initialize our quantum sampler and run our transpiled circuit on it.

We won't really be talking about what transpilation is or how Qiskit's sampler works, since these are very technical details and frankly not my area of expertise. For the purposes of our lessons this semester, you can basically substitute any Qiskit Aer code with the block above and run your quantum circuit on an actual quantum computer. The details aren't really relevant to our circuits, since they're all going to use very common gates and operations. 
</KatexSpan>